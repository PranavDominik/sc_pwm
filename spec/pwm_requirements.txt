PWM Software Component Requirements 
====================================

:Author: Dan Wilkinson
:Version: 1.0

Introduction
============

The PWM single bit and multibit component implementations are already complete but the verification and documentation is not.


Implementation
==============

The current sourcecode contains a basic Time Proportioning PWM implementation as follows:

They normally use a counter that increments periodically and is reset at the end of every period of the PWM. When the counter value is more than the reference value, the PWM output changes state from high to low (or low to high). This technique is referred to as time proportioning, particularly as time-proportioning control: which proportion of a fixed cycle time is spent in the high state.

The current source code only implements a Lead Edge variation:

Lead Edge: The lead edge can be held at the lead edge of the window and the tail edge modulated.

If possible without significant schedule impact MindTree should add Tail Edge and Centred variations, and should make the choice configurable via a build option.

Tail Edge: The tail edge can be fixed and the lead edge modulated.
Centered: The pulse center may be fixed in the center of the time window and both edges of the pulse moved to compress or expand the width

Verification
============

The testplan has not been written yet. 

All features in the spec should be validated on the simulator, and on the hardware where possible. 

Where the API specification defines error handling, these features must be tested.

MindTree should ensure the test coverage is complete and add items to the testplan as required to ensure this.

Currently, the following tests exist:

singlebit demo: Demonstrates the singlebit pwm by using the leds on the xc1a board. It uses 2 1-bit ports,  with a resolution of 32 and a timestep of 10. 

multibit demo:  Demonstrates the multibit pwm by using the leds on the xc1a board. It uses a 4-bit port,

  with a resolution of 256 and a timestep of 10.

singlebit test: Outputs a fixed pattern of duty cycles using 4 1-bit ports, a resolution of 256 and a timestep of 10. It runs with a simulator with a plugin that monitors the relevent pins and displays the current duty cycle. This test is not currently self checking, although to make it so would only require that the output be compared to the expected output.

multibittest: Outputs a fixed pattern of duty cycles using ports widths of 4, 8 and 16, a resolution of 32 and a timestep of 10, 50 and 100. It runs with a simulator with a plugin that monitors the relevent pins and displays the current duty cycle. This test is not currently self checking, although to make it so would only require that the output be compared to the expected output.

The current state of testing demonstrates that the components work with a small section of the possible configurations. The components need to be checked accross a wider range of possible configurations to complete the verification. Also the verification must cover error cases -what they do when the components are used in invalid ways. For example, if the user request a duty cycle which is greater than the max resolution, or if the resolution requested is not a power of 32. 

XTA
===

The XTA pragmas exist for the Lead Edge case and are complete. If the centred and tail edge cases are added, they should have equivalent XTA coverage.

Demonstrations
==============

The demos already exist for lead edge case. Demo for the other cases is nto required. 

Documentation
=============

Documentation deliverables are as specified in the XMOS/MindTree Statement of Work

 

